{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"smart_contracts/solc-js/test/determinism.js","filenameRelative":"smart_contracts/solc-js/test/determinism.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"smart_contracts/solc-js/test/determinism.js.map","sourceFileName":"smart_contracts/solc-js/test/determinism.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"determinism"},"ignored":false,"code":"var tape = require('tape');\n\nvar fs = require('fs');\n\nvar solc = require('../index.js');\n\ntape('Deterministic Compilation', function (t) {\n  t.test('DAO', function (st) {\n    var input = {};\n    var prevBytecode = null;\n    var files = ['DAO.sol', 'Token.sol', 'TokenCreation.sol', 'ManagedAccount.sol'];\n    var i;\n\n    for (i in meteorBabelHelpers.sanitizeForInObject(files)) {\n      var file = files[i];\n      input[file] = fs.readFileSync('test/DAO/' + file, 'utf8');\n    }\n\n    for (i = 0; i < 10; i++) {\n      var output = solc.compile({\n        sources: input\n      }, 1);\n      var bytecode = output.contracts['DAO.sol:DAO'].bytecode;\n      st.ok(bytecode.length > 0);\n\n      if (prevBytecode !== null) {\n        st.equal(prevBytecode, bytecode);\n      }\n\n      prevBytecode = bytecode; // reset compiler state\n\n      solc.compile({\n        sources: {\n          f: 'contract c {}'\n        }\n      }, 1);\n    }\n\n    st.end();\n  });\n});","map":{"version":3,"sources":["smart_contracts/solc-js/test/determinism.js"],"names":["tape","require","fs","solc","t","test","st","input","prevBytecode","files","i","file","readFileSync","output","compile","sources","bytecode","contracts","ok","length","equal","f","end"],"mappings":"AAAA,IAAMA,OAAOC,QAAQ,MAAR,CAAb;;AACA,IAAMC,KAAKD,QAAQ,IAAR,CAAX;;AACA,IAAME,OAAOF,QAAQ,aAAR,CAAb;;AAEAD,KAAK,2BAAL,EAAkC,UAAUI,CAAV,EAAa;AAC7CA,IAAEC,IAAF,CAAO,KAAP,EAAc,UAAUC,EAAV,EAAc;AAC1B,QAAIC,QAAQ,EAAZ;AACA,QAAIC,eAAe,IAAnB;AACA,QAAIC,QAAQ,CAAC,SAAD,EAAY,WAAZ,EAAyB,mBAAzB,EAA8C,oBAA9C,CAAZ;AACA,QAAIC,CAAJ;;AACA,SAAKA,CAAL,2CAAUD,KAAV,GAAiB;AACf,UAAIE,OAAOF,MAAMC,CAAN,CAAX;AACAH,YAAMI,IAAN,IAAcT,GAAGU,YAAH,CAAgB,cAAcD,IAA9B,EAAoC,MAApC,CAAd;AACD;;AACD,SAAKD,IAAI,CAAT,EAAYA,IAAI,EAAhB,EAAoBA,GAApB,EAAyB;AACvB,UAAIG,SAASV,KAAKW,OAAL,CAAa;AAACC,iBAASR;AAAV,OAAb,EAA+B,CAA/B,CAAb;AACA,UAAIS,WAAWH,OAAOI,SAAP,CAAiB,aAAjB,EAAgCD,QAA/C;AACAV,SAAGY,EAAH,CAAMF,SAASG,MAAT,GAAkB,CAAxB;;AACA,UAAIX,iBAAiB,IAArB,EAA2B;AACzBF,WAAGc,KAAH,CAASZ,YAAT,EAAuBQ,QAAvB;AACD;;AACDR,qBAAeQ,QAAf,CAPuB,CAQvB;;AACAb,WAAKW,OAAL,CAAa;AAACC,iBAAS;AAACM,aAAG;AAAJ;AAAV,OAAb,EAA8C,CAA9C;AACD;;AACDf,OAAGgB,GAAH;AACD,GArBD;AAsBD,CAvBD","file":"smart_contracts/solc-js/test/determinism.js.map","sourcesContent":["const tape = require('tape');\nconst fs = require('fs');\nconst solc = require('../index.js');\n\ntape('Deterministic Compilation', function (t) {\n  t.test('DAO', function (st) {\n    var input = {};\n    var prevBytecode = null;\n    var files = ['DAO.sol', 'Token.sol', 'TokenCreation.sol', 'ManagedAccount.sol'];\n    var i;\n    for (i in files) {\n      var file = files[i];\n      input[file] = fs.readFileSync('test/DAO/' + file, 'utf8');\n    }\n    for (i = 0; i < 10; i++) {\n      var output = solc.compile({sources: input}, 1);\n      var bytecode = output.contracts['DAO.sol:DAO'].bytecode;\n      st.ok(bytecode.length > 0);\n      if (prevBytecode !== null) {\n        st.equal(prevBytecode, bytecode);\n      }\n      prevBytecode = bytecode;\n      // reset compiler state\n      solc.compile({sources: {f: 'contract c {}'}}, 1);\n    }\n    st.end();\n  });\n});\n"]},"hash":"0fb947547c02ef6fb37609e586356cc1a17ff949"}
