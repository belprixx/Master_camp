{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"smart_contracts/solc-js/test/package.js","filenameRelative":"smart_contracts/solc-js/test/package.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"smart_contracts/solc-js/test/package.js.map","sourceFileName":"smart_contracts/solc-js/test/package.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"package"},"ignored":false,"code":"var tape = require('tape');\n\nvar solc = require('../index.js');\n\ntape('Compilation', function (t) {\n  t.test('single files can be compiled', function (st) {\n    var output = solc.compile('contract x { function g() {} }');\n    st.ok(':x' in output.contracts);\n    st.ok(output.contracts[':x'].bytecode.length > 0);\n    st.end();\n  });\n  t.test('multiple files can be compiled', function (st) {\n    var input = {\n      'lib.sol': 'library L { function f() returns (uint) { return 7; } }',\n      'cont.sol': 'import \"lib.sol\"; contract x { function g() { L.f(); } }'\n    };\n    var output = solc.compile({\n      sources: input\n    });\n    st.ok('cont.sol:x' in output.contracts);\n    st.ok('lib.sol:L' in output.contracts);\n    st.ok(output.contracts['cont.sol:x'].bytecode.length > 0);\n    st.ok(output.contracts['lib.sol:L'].bytecode.length > 0);\n    st.end();\n  });\n  t.test('lazy-loading callback works', function (st) {\n    var input = {\n      'cont.sol': 'import \"lib.sol\"; contract x { function g() { L.f(); } }'\n    };\n\n    function findImports(path) {\n      if (path === 'lib.sol') {\n        return {\n          contents: 'library L { function f() returns (uint) { return 7; } }'\n        };\n      } else {\n        return {\n          error: 'File not found'\n        };\n      }\n    }\n\n    var output = solc.compile({\n      sources: input\n    }, 0, findImports);\n    st.ok('cont.sol:x' in output.contracts);\n    st.ok('lib.sol:L' in output.contracts);\n    st.ok(output.contracts['cont.sol:x'].bytecode.length > 0);\n    st.ok(output.contracts['lib.sol:L'].bytecode.length > 0);\n    st.end();\n  });\n  t.test('compiling standard JSON', function (st) {\n    if (!solc.supportsStandard) {\n      st.skip('Not supported by solc');\n      st.end();\n      return;\n    }\n\n    var input = {\n      'language': 'Solidity',\n      'sources': {\n        'lib.sol': {\n          'content': 'library L { function f() returns (uint) { return 7; } }'\n        },\n        'cont.sol': {\n          'content': 'import \"lib.sol\"; contract x { function g() { L.f(); } }'\n        }\n      }\n    };\n\n    function bytecodeExists(output, fileName, contractName) {\n      try {\n        return output.contracts[fileName][contractName]['evm']['bytecode']['object'].length > 0;\n      } catch (e) {\n        return false;\n      }\n    }\n\n    var output = JSON.parse(solc.compileStandard(JSON.stringify(input)));\n    st.ok(bytecodeExists(output, 'cont.sol', 'x'));\n    st.ok(bytecodeExists(output, 'lib.sol', 'L'));\n    st.end();\n  });\n  t.test('compiling standard JSON (with callback)', function (st) {\n    if (!solc.supportsStandard) {\n      st.skip('Not supported by solc');\n      st.end();\n      return;\n    }\n\n    var input = {\n      'language': 'Solidity',\n      'sources': {\n        'cont.sol': {\n          'content': 'import \"lib.sol\"; contract x { function g() { L.f(); } }'\n        }\n      }\n    };\n\n    function findImports(path) {\n      if (path === 'lib.sol') {\n        return {\n          contents: 'library L { function f() returns (uint) { return 7; } }'\n        };\n      } else {\n        return {\n          error: 'File not found'\n        };\n      }\n    }\n\n    function bytecodeExists(output, fileName, contractName) {\n      try {\n        return output.contracts[fileName][contractName]['evm']['bytecode']['object'].length > 0;\n      } catch (e) {\n        return false;\n      }\n    }\n\n    var output = JSON.parse(solc.compileStandard(JSON.stringify(input), findImports));\n    st.ok(bytecodeExists(output, 'cont.sol', 'x'));\n    st.ok(bytecodeExists(output, 'lib.sol', 'L'));\n    st.end();\n  });\n  t.test('compiling standard JSON (using wrapper)', function (st) {\n    var input = {\n      'language': 'Solidity',\n      'sources': {\n        'lib.sol': {\n          'content': 'library L { function f() returns (uint) { return 7; } }'\n        },\n        'cont.sol': {\n          'content': 'import \"lib.sol\"; contract x { function g() { L.f(); } }'\n        }\n      }\n    };\n\n    function bytecodeExists(output, fileName, contractName) {\n      try {\n        return output.contracts[fileName][contractName]['evm']['bytecode']['object'].length > 0;\n      } catch (e) {\n        return false;\n      }\n    }\n\n    var output = JSON.parse(solc.compileStandardWrapper(JSON.stringify(input)));\n    st.ok(bytecodeExists(output, 'cont.sol', 'x'));\n    st.ok(bytecodeExists(output, 'lib.sol', 'L'));\n    st.end();\n  });\n});\ntape('Loading Legacy Versions', function (t) {\n  t.test('loading remote version - development snapshot', function (st) {\n    // getting the development snapshot\n    st.plan(3);\n    solc.loadRemoteVersion('latest', function (err, solcSnapshot) {\n      st.notOk(err);\n      var output = solcSnapshot.compile('contract x { function g() {} }');\n      st.ok(':x' in output.contracts);\n      st.ok(output.contracts[':x'].bytecode.length > 0);\n    });\n  });\n});\ntape('Linking', function (t) {\n  t.test('link properly', function (st) {\n    var input = {\n      'lib.sol': 'library L { function f() returns (uint) { return 7; } }',\n      'cont.sol': 'import \"lib.sol\"; contract x { function g() { L.f(); } }'\n    };\n    var output = solc.compile({\n      sources: input\n    });\n    var bytecode = solc.linkBytecode(output.contracts['cont.sol:x'].bytecode, {\n      'lib.sol:L': '0x123456'\n    });\n    st.ok(bytecode.indexOf('_') < 0);\n    st.end();\n  });\n  t.test('linker to fail with missing library', function (st) {\n    var input = {\n      'lib.sol': 'library L { function f() returns (uint) { return 7; } }',\n      'cont.sol': 'import \"lib.sol\"; contract x { function g() { L.f(); } }'\n    };\n    var output = solc.compile({\n      sources: input\n    });\n    var bytecode = solc.linkBytecode(output.contracts['cont.sol:x'].bytecode, {});\n    st.ok(bytecode.indexOf('_') >= 0);\n    st.end();\n  });\n  t.test('linker to fail with invalid address', function (st) {\n    var input = {\n      'lib.sol': 'library L { function f() returns (uint) { return 7; } }',\n      'cont.sol': 'import \"lib.sol\"; contract x { function g() { L.f(); } }'\n    };\n    var output = solc.compile({\n      sources: input\n    });\n    st.throws(function () {\n      solc.linkBytecode(output.contracts['cont.sol:x'].bytecode, {\n        'lib.sol:L': ''\n      });\n    });\n    st.end();\n  });\n  t.test('linker properly with truncated library name', function (st) {\n    var input = {\n      'lib.sol': 'library L1234567890123456789012345678901234567890 { function f() returns (uint) { return 7; } }',\n      'cont.sol': 'import \"lib.sol\"; contract x { function g() { L1234567890123456789012345678901234567890.f(); } }'\n    };\n    var output = solc.compile({\n      sources: input\n    });\n    var bytecode = solc.linkBytecode(output.contracts['cont.sol:x'].bytecode, {\n      'lib.sol:L1234567890123456789012345678901234567890': '0x123456'\n    });\n    st.ok(bytecode.indexOf('_') < 0);\n    st.end();\n  });\n});","map":{"version":3,"sources":["smart_contracts/solc-js/test/package.js"],"names":["tape","require","solc","t","test","st","output","compile","ok","contracts","bytecode","length","end","input","sources","findImports","path","contents","error","supportsStandard","skip","bytecodeExists","fileName","contractName","e","JSON","parse","compileStandard","stringify","compileStandardWrapper","plan","loadRemoteVersion","err","solcSnapshot","notOk","linkBytecode","indexOf","throws"],"mappings":"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","file":"smart_contracts/solc-js/test/package.js.map","sourcesContent":["const tape = require('tape');\nconst solc = require('../index.js');\n\ntape('Compilation', function (t) {\n  t.test('single files can be compiled', function (st) {\n    var output = solc.compile('contract x { function g() {} }');\n    st.ok(':x' in output.contracts);\n    st.ok(output.contracts[':x'].bytecode.length > 0);\n    st.end();\n  });\n  t.test('multiple files can be compiled', function (st) {\n    var input = {\n      'lib.sol': 'library L { function f() returns (uint) { return 7; } }',\n      'cont.sol': 'import \"lib.sol\"; contract x { function g() { L.f(); } }'\n    };\n    var output = solc.compile({sources: input});\n    st.ok('cont.sol:x' in output.contracts);\n    st.ok('lib.sol:L' in output.contracts);\n    st.ok(output.contracts['cont.sol:x'].bytecode.length > 0);\n    st.ok(output.contracts['lib.sol:L'].bytecode.length > 0);\n    st.end();\n  });\n  t.test('lazy-loading callback works', function (st) {\n    var input = {\n      'cont.sol': 'import \"lib.sol\"; contract x { function g() { L.f(); } }'\n    };\n    function findImports (path) {\n      if (path === 'lib.sol') {\n        return { contents: 'library L { function f() returns (uint) { return 7; } }' };\n      } else {\n        return { error: 'File not found' };\n      }\n    }\n    var output = solc.compile({sources: input}, 0, findImports);\n    st.ok('cont.sol:x' in output.contracts);\n    st.ok('lib.sol:L' in output.contracts);\n    st.ok(output.contracts['cont.sol:x'].bytecode.length > 0);\n    st.ok(output.contracts['lib.sol:L'].bytecode.length > 0);\n    st.end();\n  });\n  t.test('compiling standard JSON', function (st) {\n    if (!solc.supportsStandard) {\n      st.skip('Not supported by solc');\n      st.end();\n      return;\n    }\n\n    var input = {\n      'language': 'Solidity',\n      'sources': {\n        'lib.sol': {\n          'content': 'library L { function f() returns (uint) { return 7; } }'\n        },\n        'cont.sol': {\n          'content': 'import \"lib.sol\"; contract x { function g() { L.f(); } }'\n        }\n      }\n    };\n\n    function bytecodeExists (output, fileName, contractName) {\n      try {\n        return output.contracts[fileName][contractName]['evm']['bytecode']['object'].length > 0;\n      } catch (e) {\n        return false;\n      }\n    }\n\n    var output = JSON.parse(solc.compileStandard(JSON.stringify(input)));\n    st.ok(bytecodeExists(output, 'cont.sol', 'x'));\n    st.ok(bytecodeExists(output, 'lib.sol', 'L'));\n    st.end();\n  });\n  t.test('compiling standard JSON (with callback)', function (st) {\n    if (!solc.supportsStandard) {\n      st.skip('Not supported by solc');\n      st.end();\n      return;\n    }\n\n    var input = {\n      'language': 'Solidity',\n      'sources': {\n        'cont.sol': {\n          'content': 'import \"lib.sol\"; contract x { function g() { L.f(); } }'\n        }\n      }\n    };\n\n    function findImports (path) {\n      if (path === 'lib.sol') {\n        return { contents: 'library L { function f() returns (uint) { return 7; } }' };\n      } else {\n        return { error: 'File not found' };\n      }\n    }\n\n    function bytecodeExists (output, fileName, contractName) {\n      try {\n        return output.contracts[fileName][contractName]['evm']['bytecode']['object'].length > 0;\n      } catch (e) {\n        return false;\n      }\n    }\n\n    var output = JSON.parse(solc.compileStandard(JSON.stringify(input), findImports));\n    st.ok(bytecodeExists(output, 'cont.sol', 'x'));\n    st.ok(bytecodeExists(output, 'lib.sol', 'L'));\n    st.end();\n  });\n  t.test('compiling standard JSON (using wrapper)', function (st) {\n    var input = {\n      'language': 'Solidity',\n      'sources': {\n        'lib.sol': {\n          'content': 'library L { function f() returns (uint) { return 7; } }'\n        },\n        'cont.sol': {\n          'content': 'import \"lib.sol\"; contract x { function g() { L.f(); } }'\n        }\n      }\n    };\n\n    function bytecodeExists (output, fileName, contractName) {\n      try {\n        return output.contracts[fileName][contractName]['evm']['bytecode']['object'].length > 0;\n      } catch (e) {\n        return false;\n      }\n    }\n\n    var output = JSON.parse(solc.compileStandardWrapper(JSON.stringify(input)));\n    st.ok(bytecodeExists(output, 'cont.sol', 'x'));\n    st.ok(bytecodeExists(output, 'lib.sol', 'L'));\n    st.end();\n  });\n});\ntape('Loading Legacy Versions', function (t) {\n  t.test('loading remote version - development snapshot', function (st) {\n    // getting the development snapshot\n    st.plan(3);\n    solc.loadRemoteVersion('latest', function (err, solcSnapshot) {\n      st.notOk(err);\n      var output = solcSnapshot.compile('contract x { function g() {} }');\n      st.ok(':x' in output.contracts);\n      st.ok(output.contracts[':x'].bytecode.length > 0);\n    });\n  });\n});\n\ntape('Linking', function (t) {\n  t.test('link properly', function (st) {\n    var input = {\n      'lib.sol': 'library L { function f() returns (uint) { return 7; } }',\n      'cont.sol': 'import \"lib.sol\"; contract x { function g() { L.f(); } }'\n    };\n    var output = solc.compile({sources: input});\n    var bytecode = solc.linkBytecode(output.contracts['cont.sol:x'].bytecode, { 'lib.sol:L': '0x123456' });\n    st.ok(bytecode.indexOf('_') < 0);\n    st.end();\n  });\n\n  t.test('linker to fail with missing library', function (st) {\n    var input = {\n      'lib.sol': 'library L { function f() returns (uint) { return 7; } }',\n      'cont.sol': 'import \"lib.sol\"; contract x { function g() { L.f(); } }'\n    };\n    var output = solc.compile({sources: input});\n    var bytecode = solc.linkBytecode(output.contracts['cont.sol:x'].bytecode, { });\n    st.ok(bytecode.indexOf('_') >= 0);\n    st.end();\n  });\n\n  t.test('linker to fail with invalid address', function (st) {\n    var input = {\n      'lib.sol': 'library L { function f() returns (uint) { return 7; } }',\n      'cont.sol': 'import \"lib.sol\"; contract x { function g() { L.f(); } }'\n    };\n    var output = solc.compile({sources: input});\n    st.throws(function () {\n      solc.linkBytecode(output.contracts['cont.sol:x'].bytecode, { 'lib.sol:L': '' });\n    });\n    st.end();\n  });\n\n  t.test('linker properly with truncated library name', function (st) {\n    var input = {\n      'lib.sol': 'library L1234567890123456789012345678901234567890 { function f() returns (uint) { return 7; } }',\n      'cont.sol': 'import \"lib.sol\"; contract x { function g() { L1234567890123456789012345678901234567890.f(); } }'\n    };\n    var output = solc.compile({sources: input});\n    var bytecode = solc.linkBytecode(output.contracts['cont.sol:x'].bytecode, { 'lib.sol:L1234567890123456789012345678901234567890': '0x123456' });\n    st.ok(bytecode.indexOf('_') < 0);\n    st.end();\n  });\n});\n"]},"hash":"22ed0dc909c77b6f919a30ca9e25d87635e06a7e"}
