{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"smart_contracts/solc-js/translate.js","filenameRelative":"smart_contracts/solc-js/translate.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"smart_contracts/solc-js/translate.js.map","sourceFileName":"smart_contracts/solc-js/translate.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"translate"},"ignored":false,"code":"function translateErrors(ret, errors) {\n  for (var error in meteorBabelHelpers.sanitizeForInObject(errors)) {\n    var type = 'error';\n    var extractType = /^(.*):(\\d+):(\\d+):(.*):/;\n    extractType = extractType.exec(errors[error]);\n\n    if (extractType) {\n      type = extractType[4].trim();\n    } else if (errors[error].indexOf(': Warning:')) {\n      type = 'Warning';\n    } else if (errors[error].indexOf(': Error:')) {\n      type = 'Error';\n    }\n\n    ret.push({\n      type: type,\n      component: 'general',\n      severity: type === 'Warning' ? 'warning' : 'error',\n      message: errors[error],\n      formattedMessage: errors[error]\n    });\n  }\n}\n\nfunction translateGasEstimates(gasEstimates) {\n  if (gasEstimates === null) {\n    return 'infinite';\n  }\n\n  if (typeof gasEstimates === 'number') {\n    return gasEstimates.toString();\n  }\n\n  var gasEstimatesTranslated = {};\n\n  for (var func in meteorBabelHelpers.sanitizeForInObject(gasEstimates)) {\n    gasEstimatesTranslated[func] = translateGasEstimates(gasEstimates[func]);\n  }\n\n  return gasEstimatesTranslated;\n}\n\nfunction translateJsonCompilerOutput(output) {\n  var ret = {};\n  ret['errors'] = [];\n  translateErrors(ret['errors'], output['errors']);\n  ret['contracts'] = {};\n\n  for (var contract in meteorBabelHelpers.sanitizeForInObject(output['contracts'])) {\n    // Split name first, can be `contract`, `:contract` or `filename:contract`\n    var tmp = contract.match(/^(([^:]*):)?([^:]+)$/);\n\n    if (tmp.length !== 4) {\n      // Force abort\n      return null;\n    }\n\n    var fileName = tmp[2];\n\n    if (fileName === undefined) {\n      // this is the case of `contract`\n      fileName = '';\n    }\n\n    var contractName = tmp[3];\n    var contractInput = output['contracts'][contract];\n    var gasEstimates = contractInput['gasEstimates'];\n    var contractOutput = {\n      'abi': JSON.parse(contractInput['interface']),\n      'metadata': contractInput['metadata'],\n      'evm': {\n        'legacyAssembly': contractInput['assembly'],\n        'bytecode': {\n          'object': contractInput['bytecode'],\n          'opcodes': contractInput['opcodes'],\n          'sourceMap': contractInput['srcmap']\n        },\n        'deployedBytecode': {\n          'object': contractInput['runtimeBytecode'],\n          'sourceMap': contractInput['srcmapRuntime']\n        },\n        'methodIdentifiers': contractInput['functionHashes'],\n        'gasEstimates': {\n          'creation': {\n            'codeDepositCost': translateGasEstimates(gasEstimates['creation'][1]),\n            'executionCost': translateGasEstimates(gasEstimates['creation'][0])\n          },\n          'internal': translateGasEstimates(gasEstimates['internal']),\n          'external': translateGasEstimates(gasEstimates['external'])\n        }\n      }\n    };\n\n    if (!ret['contracts'][fileName]) {\n      ret['contracts'][fileName] = {};\n    }\n\n    ret['contracts'][fileName][contractName] = contractOutput;\n  }\n\n  var sourceMap = {};\n\n  for (var sourceId in meteorBabelHelpers.sanitizeForInObject(output['sourceList'])) {\n    sourceMap[output['sourceList'][sourceId]] = sourceId;\n  }\n\n  ret['sources'] = {};\n\n  for (var source in meteorBabelHelpers.sanitizeForInObject(output['sources'])) {\n    ret['sources'][source] = {\n      id: sourceMap[source],\n      legacyAST: output['sources'][source]\n    };\n  }\n\n  return ret;\n}\n\nmodule.exports = {\n  translateJsonCompilerOutput: translateJsonCompilerOutput\n};","map":{"version":3,"sources":["smart_contracts/solc-js/translate.js"],"names":["translateErrors","ret","errors","error","type","extractType","exec","trim","indexOf","push","component","severity","message","formattedMessage","translateGasEstimates","gasEstimates","toString","gasEstimatesTranslated","func","translateJsonCompilerOutput","output","contract","tmp","match","length","fileName","undefined","contractName","contractInput","contractOutput","JSON","parse","sourceMap","sourceId","source","id","legacyAST","module","exports"],"mappings":"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","file":"smart_contracts/solc-js/translate.js.map","sourcesContent":["function translateErrors (ret, errors) {\n  for (var error in errors) {\n    var type = 'error';\n    var extractType = /^(.*):(\\d+):(\\d+):(.*):/;\n    extractType = extractType.exec(errors[error]);\n    if (extractType) {\n      type = extractType[4].trim();\n    } else if (errors[error].indexOf(': Warning:')) {\n      type = 'Warning';\n    } else if (errors[error].indexOf(': Error:')) {\n      type = 'Error';\n    }\n    ret.push({\n      type: type,\n      component: 'general',\n      severity: (type === 'Warning') ? 'warning' : 'error',\n      message: errors[error],\n      formattedMessage: errors[error]\n    });\n  }\n}\n\nfunction translateGasEstimates (gasEstimates) {\n  if (gasEstimates === null) {\n    return 'infinite';\n  }\n\n  if (typeof gasEstimates === 'number') {\n    return gasEstimates.toString();\n  }\n\n  var gasEstimatesTranslated = {};\n  for (var func in gasEstimates) {\n    gasEstimatesTranslated[func] = translateGasEstimates(gasEstimates[func]);\n  }\n  return gasEstimatesTranslated;\n}\n\nfunction translateJsonCompilerOutput (output) {\n  var ret = {};\n\n  ret['errors'] = [];\n  translateErrors(ret['errors'], output['errors']);\n\n  ret['contracts'] = {};\n  for (var contract in output['contracts']) {\n    // Split name first, can be `contract`, `:contract` or `filename:contract`\n    var tmp = contract.match(/^(([^:]*):)?([^:]+)$/);\n    if (tmp.length !== 4) {\n      // Force abort\n      return null;\n    }\n    var fileName = tmp[2];\n    if (fileName === undefined) {\n      // this is the case of `contract`\n      fileName = '';\n    }\n    var contractName = tmp[3];\n\n    var contractInput = output['contracts'][contract];\n\n    var gasEstimates = contractInput['gasEstimates'];\n\n    var contractOutput = {\n      'abi': JSON.parse(contractInput['interface']),\n      'metadata': contractInput['metadata'],\n      'evm': {\n        'legacyAssembly': contractInput['assembly'],\n        'bytecode': {\n          'object': contractInput['bytecode'],\n          'opcodes': contractInput['opcodes'],\n          'sourceMap': contractInput['srcmap']\n        },\n        'deployedBytecode': {\n          'object': contractInput['runtimeBytecode'],\n          'sourceMap': contractInput['srcmapRuntime']\n        },\n        'methodIdentifiers': contractInput['functionHashes'],\n        'gasEstimates': {\n          'creation': {\n            'codeDepositCost': translateGasEstimates(gasEstimates['creation'][1]),\n            'executionCost': translateGasEstimates(gasEstimates['creation'][0])\n          },\n          'internal': translateGasEstimates(gasEstimates['internal']),\n          'external': translateGasEstimates(gasEstimates['external'])\n        }\n      }\n    };\n\n    if (!ret['contracts'][fileName]) {\n      ret['contracts'][fileName] = {};\n    }\n\n    ret['contracts'][fileName][contractName] = contractOutput;\n  }\n\n  var sourceMap = {};\n  for (var sourceId in output['sourceList']) {\n    sourceMap[output['sourceList'][sourceId]] = sourceId;\n  }\n\n  ret['sources'] = {};\n  for (var source in output['sources']) {\n    ret['sources'][source] = {\n      id: sourceMap[source],\n      legacyAST: output['sources'][source]\n    };\n  }\n\n  return ret;\n}\n\nmodule.exports = {\n  translateJsonCompilerOutput: translateJsonCompilerOutput\n};\n"]},"hash":"4f2856fbcda7d75fc2c01f50393be0734d2fc410"}
