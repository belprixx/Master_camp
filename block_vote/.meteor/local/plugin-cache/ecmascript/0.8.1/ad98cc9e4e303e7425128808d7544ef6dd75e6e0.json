{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"smart_contracts/solc-js/wrapper.js","filenameRelative":"smart_contracts/solc-js/wrapper.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"smart_contracts/solc-js/wrapper.js.map","sourceFileName":"smart_contracts/solc-js/wrapper.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"wrapper"},"ignored":false,"code":"var translate = require('./translate.js');\n\nvar requireFromString = require('require-from-string');\n\nvar https = require('https');\n\nvar MemoryStream = require('memorystream');\n\nfunction setupMethods(soljson) {\n  var compileJSON = soljson.cwrap('compileJSON', 'string', ['string', 'number']);\n  var compileJSONMulti = null;\n\n  if ('_compileJSONMulti' in soljson) {\n    compileJSONMulti = soljson.cwrap('compileJSONMulti', 'string', ['string', 'number']);\n  }\n\n  var compileJSONCallback = null;\n  var compileStandard = null;\n\n  if ('_compileJSONCallback' in soljson || '_compileStandard' in soljson) {\n    var copyString = function (str, ptr) {\n      var buffer = soljson._malloc(str.length + 1);\n\n      soljson.writeStringToMemory(str, buffer);\n      soljson.setValue(ptr, buffer, '*');\n    };\n\n    var wrapCallback = function (callback) {\n      return function (path, contents, error) {\n        var result = callback(soljson.Pointer_stringify(path));\n\n        if (typeof result.contents === 'string') {\n          copyString(result.contents, contents);\n        }\n\n        if (typeof result.error === 'string') {\n          copyString(result.error, error);\n        }\n      };\n    }; // This calls compile() with args || cb\n\n\n    var runWithReadCallback = function (readCallback, compile, args) {\n      if (readCallback === undefined) {\n        readCallback = function (path) {\n          return {\n            error: 'File import callback not supported'\n          };\n        };\n      }\n\n      var cb = soljson.Runtime.addFunction(wrapCallback(readCallback));\n      var output;\n\n      try {\n        args.push(cb);\n        output = compile.apply(undefined, args);\n      } catch (e) {\n        soljson.Runtime.removeFunction(cb);\n        throw e;\n      }\n\n      soljson.Runtime.removeFunction(cb);\n      return output;\n    };\n\n    var compileInternal = soljson.cwrap('compileJSONCallback', 'string', ['string', 'number', 'number']);\n\n    compileJSONCallback = function (input, optimize, readCallback) {\n      return runWithReadCallback(readCallback, compileInternal, [input, optimize]);\n    };\n\n    if ('_compileStandard' in soljson) {\n      var compileStandardInternal = soljson.cwrap('compileStandard', 'string', ['string', 'number']);\n\n      compileStandard = function (input, readCallback) {\n        return runWithReadCallback(readCallback, compileStandardInternal, [input]);\n      };\n    }\n  }\n\n  var compile = function (input, optimise, readCallback) {\n    var result = '';\n\n    if (readCallback !== undefined && compileJSONCallback !== null) {\n      result = compileJSONCallback(JSON.stringify(input), optimise, readCallback);\n    } else if (typeof input !== 'string' && compileJSONMulti !== null) {\n      result = compileJSONMulti(JSON.stringify(input), optimise);\n    } else {\n      result = compileJSON(input, optimise);\n    }\n\n    return JSON.parse(result);\n  }; // Expects a Standard JSON I/O but supports old compilers\n\n\n  var compileStandardWrapper = function (input, readCallback) {\n    if (compileStandard !== null) {\n      return compileStandard(input, readCallback);\n    }\n\n    function formatFatalError(message) {\n      return JSON.stringify({\n        errors: [{\n          'type': 'SOLCError',\n          'component': 'solcjs',\n          'severity': 'error',\n          'message': message,\n          'formattedMessage': 'Error' + message\n        }]\n      });\n    }\n\n    input = JSON.parse(input);\n\n    if (input['language'] !== 'Solidity') {\n      return formatFatalError('Only Solidity sources are supported');\n    }\n\n    if (input['sources'] == null) {\n      return formatFatalError('No input specified');\n    } // Bail out early\n\n\n    if (input['sources'].length > 1 && compileJSONMulti === null) {\n      return formatFatalError('Multiple sources provided, but compiler only supports single input');\n    }\n\n    function isOptimizerEnabled(input) {\n      return input['settings'] && input['settings']['optimizer'] && input['settings']['optimizer']['enabled'];\n    }\n\n    function translateSources(input) {\n      var sources = {};\n\n      for (var source in meteorBabelHelpers.sanitizeForInObject(input['sources'])) {\n        if (input['sources'][source]['content'] !== null) {\n          sources[source] = input['sources'][source]['content'];\n        } else {\n          // force failure\n          return null;\n        }\n      }\n\n      return sources;\n    }\n\n    function translateOutput(output) {\n      output = translate.translateJsonCompilerOutput(JSON.parse(output));\n\n      if (output == null) {\n        return formatFatalError('Failed to process output');\n      }\n\n      return JSON.stringify(output);\n    }\n\n    var sources = translateSources(input);\n\n    if (sources === null) {\n      return formatFatalError('Failed to process sources');\n    } // Try to wrap around old versions\n\n\n    if (compileJSONCallback !== null) {\n      return translateOutput(compileJSONCallback(JSON.stringify({\n        'sources': sources\n      }), isOptimizerEnabled(input), readCallback));\n    }\n\n    if (compileJSONMulti !== null) {\n      return translateOutput(compileJSONMulti(JSON.stringify({\n        'sources': sources\n      }), isOptimizerEnabled(input)));\n    } // Try our luck with an ancient compiler\n\n\n    return translateOutput(compileJSON(sources[0], isOptimizerEnabled(input)));\n  };\n\n  var linkBytecode = function (bytecode, libraries) {\n    for (var libraryName in meteorBabelHelpers.sanitizeForInObject(libraries)) {\n      // truncate to 37 characters\n      var internalName = libraryName.slice(0, 36); // prefix and suffix with __\n\n      var libLabel = '__' + internalName + Array(37 - internalName.length).join('_') + '__';\n      var hexAddress = libraries[libraryName];\n\n      if (hexAddress.slice(0, 2) !== '0x' || hexAddress.length > 42) {\n        throw new Error('Invalid address specified for ' + libraryName);\n      } // remove 0x prefix\n\n\n      hexAddress = hexAddress.slice(2);\n      hexAddress = Array(40 - hexAddress.length + 1).join('0') + hexAddress;\n\n      while (bytecode.indexOf(libLabel) >= 0) {\n        bytecode = bytecode.replace(libLabel, hexAddress);\n      }\n    }\n\n    return bytecode;\n  };\n\n  var version = soljson.cwrap('version', 'string', []);\n  return {\n    version: version,\n    compile: compile,\n    compileStandard: compileStandard,\n    compileStandardWrapper: compileStandardWrapper,\n    linkBytecode: linkBytecode,\n    supportsMulti: compileJSONMulti !== null,\n    supportsImportCallback: compileJSONCallback !== null,\n    supportsStandard: compileStandard !== null,\n    // Use the given version if available.\n    useVersion: function (versionString) {\n      return setupMethods(require('./bin/soljson-' + versionString + '.js'));\n    },\n    // Loads the compiler of the given version from the github repository\n    // instead of from the local filesystem.\n    loadRemoteVersion: function (versionString, cb) {\n      var mem = new MemoryStream(null, {\n        readable: false\n      });\n      var url = 'https://ethereum.github.io/solc-bin/bin/soljson-' + versionString + '.js';\n      https.get(url, function (response) {\n        if (response.statusCode !== 200) {\n          cb('Error retrieving binary: ' + response.statusMessage);\n        } else {\n          response.pipe(mem);\n          response.on('end', function () {\n            cb(null, setupMethods(requireFromString(mem.toString(), 'soljson-' + versionString + '.js')));\n          });\n        }\n      }).on('error', function (error) {\n        cb(error);\n      });\n    },\n    // Use this if you want to add wrapper functions around the pure module.\n    setupMethods: setupMethods\n  };\n}\n\nmodule.exports = setupMethods;","map":{"version":3,"sources":["smart_contracts/solc-js/wrapper.js"],"names":["translate","require","requireFromString","https","MemoryStream","setupMethods","soljson","compileJSON","cwrap","compileJSONMulti","compileJSONCallback","compileStandard","copyString","str","ptr","buffer","_malloc","length","writeStringToMemory","setValue","wrapCallback","callback","path","contents","error","result","Pointer_stringify","runWithReadCallback","readCallback","compile","args","undefined","cb","Runtime","addFunction","output","push","apply","e","removeFunction","compileInternal","input","optimize","compileStandardInternal","optimise","JSON","stringify","parse","compileStandardWrapper","formatFatalError","message","errors","isOptimizerEnabled","translateSources","sources","source","translateOutput","translateJsonCompilerOutput","linkBytecode","bytecode","libraries","libraryName","internalName","slice","libLabel","Array","join","hexAddress","Error","indexOf","replace","version","supportsMulti","supportsImportCallback","supportsStandard","useVersion","versionString","loadRemoteVersion","mem","readable","url","get","response","statusCode","statusMessage","pipe","on","toString","module","exports"],"mappings":"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","file":"smart_contracts/solc-js/wrapper.js.map","sourcesContent":["var translate = require('./translate.js');\nvar requireFromString = require('require-from-string');\nvar https = require('https');\nvar MemoryStream = require('memorystream');\n\nfunction setupMethods (soljson) {\n  var compileJSON = soljson.cwrap('compileJSON', 'string', ['string', 'number']);\n  var compileJSONMulti = null;\n  if ('_compileJSONMulti' in soljson) {\n    compileJSONMulti = soljson.cwrap('compileJSONMulti', 'string', ['string', 'number']);\n  }\n  var compileJSONCallback = null;\n  var compileStandard = null;\n  if (('_compileJSONCallback' in soljson) || ('_compileStandard' in soljson)) {\n    var copyString = function (str, ptr) {\n      var buffer = soljson._malloc(str.length + 1);\n      soljson.writeStringToMemory(str, buffer);\n      soljson.setValue(ptr, buffer, '*');\n    };\n    var wrapCallback = function (callback) {\n      return function (path, contents, error) {\n        var result = callback(soljson.Pointer_stringify(path));\n        if (typeof result.contents === 'string') {\n          copyString(result.contents, contents);\n        }\n        if (typeof result.error === 'string') {\n          copyString(result.error, error);\n        }\n      };\n    };\n\n    // This calls compile() with args || cb\n    var runWithReadCallback = function (readCallback, compile, args) {\n      if (readCallback === undefined) {\n        readCallback = function (path) {\n          return {\n            error: 'File import callback not supported'\n          };\n        };\n      }\n      var cb = soljson.Runtime.addFunction(wrapCallback(readCallback));\n      var output;\n      try {\n        args.push(cb);\n        output = compile.apply(undefined, args);\n      } catch (e) {\n        soljson.Runtime.removeFunction(cb);\n        throw e;\n      }\n      soljson.Runtime.removeFunction(cb);\n      return output;\n    };\n\n    var compileInternal = soljson.cwrap('compileJSONCallback', 'string', ['string', 'number', 'number']);\n    compileJSONCallback = function (input, optimize, readCallback) {\n      return runWithReadCallback(readCallback, compileInternal, [ input, optimize ]);\n    };\n    if ('_compileStandard' in soljson) {\n      var compileStandardInternal = soljson.cwrap('compileStandard', 'string', ['string', 'number']);\n      compileStandard = function (input, readCallback) {\n        return runWithReadCallback(readCallback, compileStandardInternal, [ input ]);\n      };\n    }\n  }\n\n  var compile = function (input, optimise, readCallback) {\n    var result = '';\n    if (readCallback !== undefined && compileJSONCallback !== null) {\n      result = compileJSONCallback(JSON.stringify(input), optimise, readCallback);\n    } else if (typeof input !== 'string' && compileJSONMulti !== null) {\n      result = compileJSONMulti(JSON.stringify(input), optimise);\n    } else {\n      result = compileJSON(input, optimise);\n    }\n    return JSON.parse(result);\n  };\n\n  // Expects a Standard JSON I/O but supports old compilers\n  var compileStandardWrapper = function (input, readCallback) {\n    if (compileStandard !== null) {\n      return compileStandard(input, readCallback);\n    }\n\n    function formatFatalError (message) {\n      return JSON.stringify({\n        errors: [\n          {\n            'type': 'SOLCError',\n            'component': 'solcjs',\n            'severity': 'error',\n            'message': message,\n            'formattedMessage': 'Error' + message\n          }\n        ]\n      });\n    }\n\n    input = JSON.parse(input);\n\n    if (input['language'] !== 'Solidity') {\n      return formatFatalError('Only Solidity sources are supported');\n    }\n\n    if (input['sources'] == null) {\n      return formatFatalError('No input specified');\n    }\n\n    // Bail out early\n    if ((input['sources'].length > 1) && (compileJSONMulti === null)) {\n      return formatFatalError('Multiple sources provided, but compiler only supports single input');\n    }\n\n    function isOptimizerEnabled (input) {\n      return input['settings'] && input['settings']['optimizer'] && input['settings']['optimizer']['enabled'];\n    }\n\n    function translateSources (input) {\n      var sources = {};\n      for (var source in input['sources']) {\n        if (input['sources'][source]['content'] !== null) {\n          sources[source] = input['sources'][source]['content'];\n        } else {\n          // force failure\n          return null;\n        }\n      }\n      return sources;\n    }\n\n    function translateOutput (output) {\n      output = translate.translateJsonCompilerOutput(JSON.parse(output));\n      if (output == null) {\n        return formatFatalError('Failed to process output');\n      }\n      return JSON.stringify(output);\n    }\n\n    var sources = translateSources(input);\n    if (sources === null) {\n      return formatFatalError('Failed to process sources');\n    }\n\n    // Try to wrap around old versions\n    if (compileJSONCallback !== null) {\n      return translateOutput(compileJSONCallback(JSON.stringify({ 'sources': sources }), isOptimizerEnabled(input), readCallback));\n    }\n\n    if (compileJSONMulti !== null) {\n      return translateOutput(compileJSONMulti(JSON.stringify({ 'sources': sources }), isOptimizerEnabled(input)));\n    }\n\n    // Try our luck with an ancient compiler\n    return translateOutput(compileJSON(sources[0], isOptimizerEnabled(input)));\n  };\n\n  var linkBytecode = function (bytecode, libraries) {\n    for (var libraryName in libraries) {\n      // truncate to 37 characters\n      var internalName = libraryName.slice(0, 36);\n      // prefix and suffix with __\n      var libLabel = '__' + internalName + Array(37 - internalName.length).join('_') + '__';\n\n      var hexAddress = libraries[libraryName];\n      if (hexAddress.slice(0, 2) !== '0x' || hexAddress.length > 42) {\n        throw new Error('Invalid address specified for ' + libraryName);\n      }\n      // remove 0x prefix\n      hexAddress = hexAddress.slice(2);\n      hexAddress = Array(40 - hexAddress.length + 1).join('0') + hexAddress;\n\n      while (bytecode.indexOf(libLabel) >= 0) {\n        bytecode = bytecode.replace(libLabel, hexAddress);\n      }\n    }\n\n    return bytecode;\n  };\n\n  var version = soljson.cwrap('version', 'string', []);\n\n  return {\n    version: version,\n    compile: compile,\n    compileStandard: compileStandard,\n    compileStandardWrapper: compileStandardWrapper,\n    linkBytecode: linkBytecode,\n    supportsMulti: compileJSONMulti !== null,\n    supportsImportCallback: compileJSONCallback !== null,\n    supportsStandard: compileStandard !== null,\n    // Use the given version if available.\n    useVersion: function (versionString) {\n      return setupMethods(require('./bin/soljson-' + versionString + '.js'));\n    },\n    // Loads the compiler of the given version from the github repository\n    // instead of from the local filesystem.\n    loadRemoteVersion: function (versionString, cb) {\n      var mem = new MemoryStream(null, {readable: false});\n      var url = 'https://ethereum.github.io/solc-bin/bin/soljson-' + versionString + '.js';\n      https.get(url, function (response) {\n        if (response.statusCode !== 200) {\n          cb('Error retrieving binary: ' + response.statusMessage);\n        } else {\n          response.pipe(mem);\n          response.on('end', function () {\n            cb(null, setupMethods(requireFromString(mem.toString(), 'soljson-' + versionString + '.js')));\n          });\n        }\n      }).on('error', function (error) {\n        cb(error);\n      });\n    },\n    // Use this if you want to add wrapper functions around the pure module.\n    setupMethods: setupMethods\n  };\n}\n\nmodule.exports = setupMethods;\n"]},"hash":"ad98cc9e4e303e7425128808d7544ef6dd75e6e0"}
